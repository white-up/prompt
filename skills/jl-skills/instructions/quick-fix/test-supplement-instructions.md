# 单元测试补充指令 (Test Supplement Instructions)

## ⚠️ 执行规则 (EXECUTION RULES)

```
🛑 CRITICAL: 
- 每个步骤输出后 MUST STOP
- 等待用户回复后才能继续
- 一次回复只输出一个步骤的内容
- 违反此规则将导致流程失败
```

此文档指导 Agent 执行快速改动流程的**阶段 2: 单元测试补充**。

> [!IMPORTANT]
> **目标**: 为已有功能补充完整的单元测试，确保改动安全。
> **原则**:
> - 先检查现有测试覆盖情况，不够则补齐
> - 确保老功能的测试先通过（🟢 绿灯），再修改代码
> - 遵循 TDD 原则，为老功能建立测试基线
    > **测试方法命名规范**: 参考 `jl-skills/specs/Java编码规范.md` - 方法名全英文下划线命名，中文意图使用 `@DisplayName("")` 注解。

---

## 步骤 2.1: 测试覆盖分析

**你必须输出以下内容，然后停止**:

### 2.1.1 分析现有测试覆盖情况

**分析内容**:
1. **检查测试文件是否存在**:
    - 查找对应的测试类（如 `XxxServiceTest.java`）
    - 检查测试方法覆盖情况

2. **识别测试缺口**:
    - 哪些方法没有测试
    - 哪些方法测试不完整（缺少边界用例、异常用例）
    - **重点**: 需要修改的方法是否有完整的测试覆盖

3. **确定需要补充的测试**:
    - **正常流程测试**（必须）
    - **异常流程测试**（必须）
    - **边界条件测试**（必须）
    - （Bug修复场景）问题场景测试

4. **评估测试完整性**:
    - 如果测试不完整，必须先补齐
    - 确保老功能的所有测试场景都有覆盖

### 2.1.2 输出测试覆盖分析

**输出格式**:

````markdown
## 步骤 2.1: 测试覆盖分析

📊 **进度**: [2/6] 单元测试补充
[████████░░░░░░░░░░░░] 33%

| ✅ 已完成 | 🔄 进行中 | ⏳ 待完成 |
|:----------|:----------|:----------|
| 1.需求明确与变更分析 | 2.1.测试覆盖分析 | 2.2.测试代码生成 |
| | | 3.代码修改 |
| | | 4.测试验证 |
| | | 5.生命周期提示 |

---

### 当前测试覆盖情况

| 文件 | 方法 | 测试文件 | 测试覆盖 | 需要补充 |
|------|------|---------|---------|---------|
| `XxxService.java` | `method1()` | `XxxServiceTest.java` | ✅ 有测试 | ❌ 需补充边界用例 |
| `XxxService.java` | `method2()` | `XxxServiceTest.java` | ❌ 无测试 | ✅ 需补充完整测试 |
| `YyyController.java` | `createYyy()` | `YyyControllerTest.java` | ✅ 有测试 | ✅ 覆盖完整 |

---

### 测试缺口分析

**需要补充的测试场景**:

| 文件 | 方法 | 测试场景 | 优先级 |
|------|------|---------|--------|
| `XxxService.java` | `method1()` | 边界值测试（空值、最大值） | P0 |
| `XxxService.java` | `method1()` | 异常流程测试（业务异常） | P0 |
| `XxxService.java` | `method2()` | 正常流程测试 | P0 |
| `XxxService.java` | `method2()` | 异常流程测试 | P0 |

---

📋 **确认检查点**

测试覆盖分析是否准确？

- 回复 **确认** → 进入测试代码生成
- 回复 **补充场景: [场景描述]** → 我将添加测试场景
- 回复 **调整** → 我将重新分析

**请确认：** 测试覆盖分析是否正确？
````

**🛑 STOP HERE - DO NOT OUTPUT STEP 2.2 UNTIL USER CONFIRMS**

⚠️ **重要**: 用户未回复"确认"前，禁止执行任何后续步骤，禁止输出步骤2.2的内容。

---

## 步骤 2.2: 测试代码生成

**你必须输出以下内容，然后停止**:

### 2.2.1 生成测试代码

**生成规则**:
1. **遵循 TDD 原则**: 先写测试（Red 阶段）
2. **测试代码直接写入文件**: 不打印到对话框
3. **使用 BDD 风格**: Given-When-Then 结构（如适用）

**生成内容**:
1. **测试类结构**:
    - 测试类名：`XxxServiceTest.java`
    - **测试方法命名规范（强制）**:
        - **方法名**: 全英文，下划线命名，格式：`test_{methodName}_{condition}_{expectedResult}`
        - **中文意图**: 使用 `@DisplayName("中文描述")` 注解
        - **TDD 阶段标识（强制）**: 这是为老功能补充的测试，应该先通过（🟢 绿灯），所以使用 `@DisplayName("🟢 正常流程：...")`
        - **示例**:
            - `test_method1_normalFlow_shouldReturnSuccess()` + `@DisplayName("🟢 正常流程：应返回成功结果")`
            - `test_method1_nullInput_shouldThrowException()` + `@DisplayName("🟢 异常流程：空值输入应抛出异常")`
            - `test_method1_boundaryValue_emptyValue_shouldThrowException()` + `@DisplayName("🟢 边界值：空值应抛出异常")`

2. **测试场景**:
    - 正常流程测试
    - 异常流程测试
    - 边界条件测试
    - （Bug修复场景）问题场景测试

3. **Mock 和断言**:
    - 使用 Mockito 等框架进行 Mock
    - 使用 AssertJ 或 JUnit 进行断言

### 2.2.2 输出测试代码生成说明

**输出格式**:

````markdown
## 步骤 2.2: 测试代码生成

📊 **进度**: [2/6] 单元测试补充
[████████░░░░░░░░░░░░] 33%

| ✅ 已完成 | 🔄 进行中 | ⏳ 待完成 |
|:----------|:----------|:----------|
| 1.需求明确与变更分析 | 2.2.测试代码生成 | 2.3.红灯确认 |
| 2.1.测试覆盖分析 | | 3.代码修改 |
| | | 4.测试验证 |
| | | 5.生命周期提示 |

---

### 即将生成的测试用例

**测试文件**: `src/test/java/.../XxxServiceTest.java`

**测试场景**:

| 测试方法 | @DisplayName | 场景描述 | 预期结果 |
|---------|-------------|---------|---------|
| `test_method1_normalFlow_shouldReturnSuccess()` | `@DisplayName("🟢 正常流程：应返回成功结果")` | 正常输入，验证成功 | 返回正确结果 |
| `test_method1_nullInput_shouldThrowException()` | `@DisplayName("🟢 边界值：空值输入应抛出异常")` | 输入为空，验证异常 | 抛出 IllegalArgumentException |
| `test_method1_businessRuleViolation_shouldThrowBusinessException()` | `@DisplayName("🟢 异常流程：业务规则不满足应抛出业务异常")` | 业务规则不满足，验证异常 | 抛出 BusinessException |
| `test_method2_normalFlow_shouldReturnSuccess()` | `@DisplayName("🟢 正常流程：应返回成功结果")` | 正常输入，验证成功 | 返回正确结果 |

**测试框架**:
- JUnit 5
- Mockito
- AssertJ

---

📋 **确认检查点**

是否开始生成测试代码？

- 回复 **确认** → 立即写入测试文件
- 回复 **调整** → 我将修改测试场景

**请确认：** 是否开始生成测试代码？
````

**🛑 STOP HERE - DO NOT OUTPUT STEP 2.3 UNTIL USER CONFIRMS**

⚠️ **重要**: 用户未回复"确认"前，禁止执行任何后续步骤，禁止输出步骤2.3的内容。

---

## 步骤 2.3: 测试代码写入与绿灯确认（老功能测试）

**你必须输出以下内容，然后停止**:

### 2.3.1 直接写入测试文件

**执行规则**:
- ⚠️ **重要**: 测试代码直接写入文件，**不打印到对话框**
- 只显示文件列表和测试方法列表
- **关键**: 这是为老功能补充的测试，应该先通过（🟢 绿灯）
- **测试方法命名规范（强制）**:
    - **方法名**: 全英文，下划线命名，格式：`test_{methodName}_{condition}_{expectedResult}`
    - **中文意图**: 使用 `@DisplayName("中文描述")` 注解
    - **TDD 阶段标识（强制）**: 这是为老功能补充的测试，应该先通过（🟢 绿灯），所以使用 `@DisplayName("🟢 正常流程：...")`
    - **参考**: `jl-skills/specs/Java编码规范.md` 中的单元测试命名规范

**写入完成后输出**:

````markdown
### ✅ 测试代码已写入

**测试文件**:
- `src/test/java/.../XxxServiceTest.java`

**测试方法**:
- `test_method1_normalFlow_shouldReturnSuccess()` + `@DisplayName("🟢 正常流程：应返回成功结果")`
- `test_method1_nullInput_shouldThrowException()` + `@DisplayName("🟢 边界值：空值输入应抛出异常")`
- `test_method1_businessRuleViolation_shouldThrowBusinessException()` + `@DisplayName("🟢 异常流程：业务规则不满足应抛出业务异常")`
- `test_method2_normalFlow_shouldReturnSuccess()` + `@DisplayName("🟢 正常流程：应返回成功结果")`

---

🛑 **关键步骤：确认老功能测试通过（🟢 绿灯）**

请执行以下操作：

1. **运行测试**
   ```bash
   mvn test
   # 或
   ./gradlew test
   ```

2. **确认测试通过**（这是预期的 🟢 绿灯状态）
    - ✅ 这些测试是为**老功能**补充的测试
    - ✅ 老功能应该正常工作，所以测试应该通过
    - ✅ 这建立了测试基线，确保后续修改不会破坏老功能

3. **如果测试失败**:
    - 可能是测试用例写错了，请告诉我具体错误信息
    - 可能是老功能本身有问题，需要先修复老功能

4. **检查语法问题**
    - 如有语法错误，请告诉我具体错误信息

---

📋 **确认检查点**

- 回复 **绿灯确认** → 测试已执行，确认通过（🟢 绿灯），老功能测试基线建立完成
- 回复 **测试失败: [具体错误信息]** → 我将修复测试代码或协助排查问题
- 回复 **语法错误: [具体错误信息]** → 我将修复测试代码
- 回复 **调整测试: [具体说明]** → 我将修改测试

**请确认：** 老功能的测试是否已执行并确认通过（🟢 绿灯）？
````

**🛑 STOP HERE - 等待用户执行测试并确认绿灯**

---

### 2.3.2 处理测试失败或错误（如需要）

**触发条件**: 用户回复 `测试失败: [具体错误信息]`、`语法错误: [具体错误信息]` 或 `调整测试: [具体说明]`

**处理流程**:
1. 读取用户报告的错误或调整需求
2. 分析问题：
    - 如果是测试用例写错了 → 修复测试代码
    - 如果是老功能本身有问题 → 先修复老功能，再补充测试
3. 修复代码或测试
4. **重新写入文件**（覆盖原文件）
5. 输出修复说明，**再次要求用户执行测试确认绿灯**

**输出格式**:

````markdown
### ✅ 测试代码已修复并重新写入

**修复内容**:
- [修复点1]
- [修复点2]

**测试文件**: `src/test/java/.../XxxServiceTest.java`

---

🛑 **请再次执行测试确认绿灯**

请执行以下操作：
1. **运行测试**
   ```bash
   mvn test
   ```

2. **确认测试通过**（🟢 绿灯）

**请确认：** 老功能的测试是否已执行并确认通过（🟢 绿灯）？
````

**🛑 STOP HERE - 等待用户再次确认绿灯**

---

## 阶段 2 完成: 准备进入代码修改

**触发条件**: 用户确认绿灯后（老功能测试通过）

**输出格式**:

````markdown
---

## ✅ 阶段 2 完成

| ✅ 已完成 | 🔄 即将开始 |
|:----------|:------------|
| 阶段1: 需求明确与变更分析 | 阶段3: 代码修改 |
| 阶段2: 单元测试补充 | |

### 📄 测试文件已写入

**文件**: `src/test/java/.../XxxServiceTest.java`

**测试状态**: 🟢 绿灯（老功能测试通过，测试基线已建立）

**测试基线说明**:
- ✅ 老功能的完整测试已补充
- ✅ 所有测试通过，建立了可靠的测试基线
- ✅ 后续代码修改时，这些测试将确保不破坏老功能

---

🛑 **下一步**

现在进入阶段3: 代码修改，实施改动。
- 修改代码后，这些测试可能会失败（🔴 红灯），这是正常的
- 需要调整代码让测试通过（🟢 绿灯）

是否进入代码修改阶段？

请回复：
- **继续** → 进入阶段3: 代码修改
- **结束** → 完成当前流程
````

**🛑 STOP HERE - 等待用户确认进入下一阶段**