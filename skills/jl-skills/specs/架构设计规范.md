# 架构设计原则与规范

## 0. 核心愿景

* **控制复杂度**：软件的核心挑战在于复杂度的非线性增长。架构的目标是将复杂度控制在“有界上下文”内。
* **业务对齐**：架构必须反映业务形态。代码结构应与业务领域模型保持一致（康威定律）。
* **可演进性**：架构不是一成不变的，设计时需预留扩展点（OCP原则），支持低成本的业务迭代。

## 1. DDD（领域驱动设计）落地原则

### 1.1 统一语言 (Ubiquitous Language)

* **原则**：代码中的类名、方法名、属性名必须与产品经理、业务专家的口头语言（业务术语）保持严格一致。
* **红线**：禁止出现业务人员看不懂的“技术术语”作为核心领域对象名称。
* *反例*：`DataHandler`, `ProcessManager`
* *正例*：`PaymentOrder`, `RefundPolicy`, `AccountBalance`

### 1.2 限界上下文 (Bounded Context)

* **原则**：明确系统的边界。每个上下文内部模型统一，上下文之间通过**防腐层 (ACL)** 交互。
* **红线**：严禁跨服务的数据库直接联表查询。A 服务通过 API 调用 B 服务，必须在 Adapter 层进行数据转换，隔离模型污染。

### 1.3 充血模型 (Rich Domain Model)

## 2. SOLID 设计原则（面向对象五大定律）

### 2.1 单一职责原则 (SRP)

* **解读**：一个类/方法应该只有一个引起它变化的原因。
* **检测**：如果你在修改“订单状态流转”逻辑时，还需要修改“发送短信”的代码，说明违背了 SRP。
* **落地**：将复杂的 `OrderService` 拆分为 `OrderCreateService`, `OrderPayService`, `OrderNotificationService`。

### 2.2 开闭原则 (OCP)

* **解读**：对扩展开放，对修改关闭。
* **落地**：当新增一种“支付渠道”时，不应去修改原本的 `if-else` 代码块，而应新增一个 `PaymentStrategy` 的实现类。

### 2.3 里氏替换原则 (LSP)

* **解读**：子类必须能完全替换父类，且不破坏程序逻辑。
* **红线**：子类中严禁抛出 `UnsupportedOperationException`，如果子类不支持父类的方法，说明继承关系有问题。

### 2.4 接口隔离原则 (ISP)

* **解读**：接口要小而精。
* **落地**：不要定义一个庞大的 `CommonService` 接口。将读写分离，定义 `Reader` 和 `Writer` 接口。

### 2.5 依赖倒置原则 (DIP)

* **解读**：高层不依赖底层，二者都依赖抽象。
* **落地**：业务层只依赖 `Repository` 接口，不依赖 `MyBatis` 或 `JPA` 的具体实现。

## 3. 设计模式应用规范

### 3.1 策略模式 (Strategy Pattern)

* **场景**：消除复杂的 `if-else` 或 `switch-case`。
* **示例**：不同的会员折扣计算、不同的支付渠道对接。
* **要求**：利用 Map 或 Spring 的自动注入（`Map<String, Strategy>`）来管理策略，避免手动 switch。

### 3.2 模板方法模式 (Template Method)

* **场景**：业务流程骨架固定，但某些步骤有差异。
* **示例**：退款流程（校验 -> 冻结 -> **执行退款(差异点)** -> 通知）。
* **要求**：在抽象父类中定义 `final` 的主流程方法，子类仅实现差异化的 `protected abstract` 方法。

### 3.3 工厂模式 (Factory Pattern)

* **场景**：领域对象的构建过程复杂（涉及参数校验、默认值初始化）。
* **要求**：复杂的 Aggregate（聚合根）创建，必须封装在 Factory 中，禁止在 Controller 层直接 `new` 出半成品对象。

### 3.4 状态模式 (State Pattern)

* **场景**：涉及复杂状态流转的实体（如订单、工单）。
* **要求**：严禁使用字符串或整数直接判断状态。应将状态行为封装为对象，或使用状态机引擎（如 Spring StateMachine 或简化版状态机）。

## 4. 分布式系统设计原则

### 4.1 幂等性设计 (Idempotency)

* **原则**：对于写操作（转账、支付、修改），系统必须保证“多次调用与一次调用的结果一致”。
* **落地**：
* 数据库层面：利用唯一索引（Unique Key）。
* 业务层面：Token 机制或状态机检查（如：订单已支付，再次收到支付请求应直接返回成功或状态已变更提示，不能重复扣款）。


### 4.2 最终一致性 (Eventual Consistency)

* **原则**：在跨服务交互中，放弃 ACID 强一致性，追求 BASE 最终一致性。
* **落地**：使用消息队列（MQ）解耦。本地事务成功后发送消息，下游服务异步消费。如果失败，依赖“重试机制”或“死信队列 + 人工/定时补偿”。

### 4.3 接口兼容性

* **原则**：对外的 API 必须向后兼容。
* **红线**：
* 严禁直接修改字段含义。
* 严禁删除正在使用的字段。
* 新增必填项必须通过新的 API 版本发布，或在该版本中设为选填。

## 5. 数据库设计原则

### 5.1 三大范式与反范式

* **原则**：遵循第三范式（3NF），但在高并发读取场景下，**允许适度冗余**（反范式）以减少 Join 操作。
* **示例**：在“订单表”中冗余“用户昵称”，避免查询订单列表时每次都去查用户服务。

### 5.2 索引规范

* **原则**：
* 禁止在索引列上进行函数运算（导致索引失效）。
* 最左前缀原则：组合索引 `(a, b, c)`，查询 `a` 或 `a,b` 有效，直接查 `b` 无效。

* **强制**：所有表必须包含 `create_time`（创建时间）和 `update_time`（修改时间），且由数据库自动维护或框架统一维护。

## 6. 架构审查清单 (Architecture Review Checklist)

在进行技术方案评审（Design Review）时，必须回答以下问题：

### 6.1 复杂度审查

* [ ] 核心业务逻辑是否被分散在 Controller 或 Utils 中？（应下沉至 Domain）
* [ ] 是否引入了不必要的中间件？（如：数据量很小却引入了 ES）
* [ ] 新增功能是否破坏了现有的分层边界？

### 6.2 扩展性审查

* [ ] 如果未来业务规则变更（如费率调整），是否需要修改代码逻辑？（还是只需改配置/数据库）
* [ ] 如果新增一种业务类型，是否需要大量修改原有类的 `if-else`？

### 6.3 稳定性审查

* [ ] 关键链路是否有熔断、降级预案？
* [ ] 外部接口调用是否有超时设置？
* [ ] 所有的写接口是否都考虑了幂等性？

### 6.4 安全性审查

* [ ] 是否存在越权访问风险（IDOR）？
* [ ] 敏感数据（密码、身份证、卡号）是否加密存储？
* [ ] SQL 注入和 XSS 漏洞是否已防御？

### 结语

架构设计的本质是**权衡 (Trade-off)**。没有完美的架构，只有最适合当前业务阶段和团队能力的架构。在遵守上述原则的基础上，请保持“简单实用 (KISS)”的心态，**杜绝过度设计**。